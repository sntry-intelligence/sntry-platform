# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class AgentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Agent]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Agent.prisma().query_raw(
            'SELECT * FROM Agent WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Agent
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Agent.prisma().query_first(
            'SELECT * FROM Agent WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AgentCreateInput,
        include: Optional[types.AgentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Agent record.

        Parameters
        ----------
        data
            Agent record data
        include
            Specifies which relations should be loaded on the returned Agent model

        Returns
        -------
        prisma.models.Agent
            The created Agent record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Agent record from just the required fields
        agent = await Agent.prisma().create(
            data={
                # data to create a Agent record
                'name': 'ggciceaie',
                'modelId': 'bbehjachib',
                'role': 'cadfabfehe',
                'orchestrationType': 'dgiiaaijj',
                'configuration': Json({'bfaiacjjfc': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AgentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Agent records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Agent record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Agent.prisma().create_many(
            data=[
                {
                    # data to create a Agent record
                    'name': 'eigcfgbif',
                    'modelId': 'bagcfbhiig',
                    'role': 'cghideieh',
                    'orchestrationType': 'biabhbdai',
                    'configuration': Json({'idghgaicb': True}),
                },
                {
                    # data to create a Agent record
                    'name': 'fjfddhigg',
                    'modelId': 'hjaecfifb',
                    'role': 'cbbbjbfcii',
                    'orchestrationType': 'bbejhfidcb',
                    'configuration': Json({'bgeecijdgg': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AgentWhereUniqueInput,
        include: Optional[types.AgentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Agent record.

        Parameters
        ----------
        where
            Agent filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Agent model

        Returns
        -------
        prisma.models.Agent
            The deleted Agent record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agent = await Agent.prisma().delete(
            where={
                'id': 'bdiicjafbj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AgentWhereUniqueInput,
        include: Optional[types.AgentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Agent record.

        Parameters
        ----------
        where
            Agent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Agent model

        Returns
        -------
        prisma.models.Agent
            The found Agent record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agent = await Agent.prisma().find_unique(
            where={
                'id': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AgentWhereUniqueInput,
        include: Optional[types.AgentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Agent record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Agent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Agent model

        Returns
        -------
        prisma.models.Agent
            The found Agent record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agent = await Agent.prisma().find_unique_or_raise(
            where={
                'id': 'bghffegacj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentWhereInput] = None,
        cursor: Optional[types.AgentWhereUniqueInput] = None,
        include: Optional[types.AgentInclude] = None,
        order: Optional[Union[types.AgentOrderByInput, List[types.AgentOrderByInput]]] = None,
        distinct: Optional[List[types.AgentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Agent records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Agent records returned
        skip
            Ignore the first N results
        where
            Agent filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Agent model
        order
            Order the returned Agent records by any field
        distinct
            Filter Agent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Agent]
            The list of all Agent records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Agent records
        agents = await Agent.prisma().find_many(take=10)

        # find the first 5 Agent records ordered by the description field
        agents = await Agent.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgentWhereInput] = None,
        cursor: Optional[types.AgentWhereUniqueInput] = None,
        include: Optional[types.AgentInclude] = None,
        order: Optional[Union[types.AgentOrderByInput, List[types.AgentOrderByInput]]] = None,
        distinct: Optional[List[types.AgentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Agent record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Agent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Agent model
        order
            Order the returned Agent records by any field
        distinct
            Filter Agent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Agent
            The first Agent record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Agent record ordered by the modelId field
        agent = await Agent.prisma().find_first(
            skip=1,
            order={
                'modelId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgentWhereInput] = None,
        cursor: Optional[types.AgentWhereUniqueInput] = None,
        include: Optional[types.AgentInclude] = None,
        order: Optional[Union[types.AgentOrderByInput, List[types.AgentOrderByInput]]] = None,
        distinct: Optional[List[types.AgentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Agent record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Agent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Agent model
        order
            Order the returned Agent records by any field
        distinct
            Filter Agent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Agent
            The first Agent record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Agent record ordered by the role field
        agent = await Agent.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AgentUpdateInput,
        where: types.AgentWhereUniqueInput,
        include: Optional[types.AgentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Agent record.

        Parameters
        ----------
        data
            Agent record data specifying what to update
        where
            Agent filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Agent model

        Returns
        -------
        prisma.models.Agent
            The updated Agent record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        agent = await Agent.prisma().update(
            where={
                'id': 'bhghchehcc',
            },
            data={
                # data to update the Agent record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AgentWhereUniqueInput,
        data: types.AgentUpsertInput,
        include: Optional[types.AgentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Agent filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Agent model

        Returns
        -------
        prisma.models.Agent
            The created or updated Agent record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agent = await Agent.prisma().upsert(
            where={
                'id': 'dcgchcbbf',
            },
            data={
                'create': {
                    'id': 'dcgchcbbf',
                    'name': 'fjfddhigg',
                    'modelId': 'hjaecfifb',
                    'role': 'cbbbjbfcii',
                    'orchestrationType': 'bbejhfidcb',
                    'configuration': Json({'bgeecijdgg': True}),
                },
                'update': {
                    'name': 'fjfddhigg',
                    'modelId': 'hjaecfifb',
                    'role': 'cbbbjbfcii',
                    'orchestrationType': 'bbejhfidcb',
                    'configuration': Json({'bgeecijdgg': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AgentUpdateManyMutationInput,
        where: types.AgentWhereInput,
    ) -> int:
        """Update multiple Agent records

        Parameters
        ----------
        data
            Agent data to update the selected Agent records to
        where
            Filter to select the Agent records to update

        Returns
        -------
        int
            The total number of Agent records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Agent records
        total = await Agent.prisma().update_many(
            data={
                'orchestrationType': 'bdedcabahc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentWhereInput] = None,
        cursor: Optional[types.AgentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Agent records present in the database

        Parameters
        ----------
        select
            Select the Agent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Agent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Agent.prisma().count()

        # results: prisma.types.AgentCountAggregateOutput
        results = await Agent.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AgentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentWhereInput] = None,
        cursor: Optional[types.AgentWhereUniqueInput] = None,
    ) -> types.AgentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AgentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentWhereInput] = None,
        cursor: Optional[types.AgentWhereUniqueInput] = None,
    ) -> Union[int, types.AgentCountAggregateOutput]:
        """Count the number of Agent records present in the database

        Parameters
        ----------
        select
            Select the Agent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Agent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Agent.prisma().count()

        # results: prisma.types.AgentCountAggregateOutput
        results = await Agent.prisma().count(
            select={
                '_all': True,
                'configuration': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AgentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AgentWhereInput] = None
    ) -> int:
        """Delete multiple Agent records.

        Parameters
        ----------
        where
            Optional Agent filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Agent records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Agent records
        total = await Agent.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AgentScalarFieldKeys'],
        *,
        where: Optional['types.AgentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AgentAvgAggregateInput'] = None,
        sum: Optional['types.AgentSumAggregateInput'] = None,
        min: Optional['types.AgentMinAggregateInput'] = None,
        max: Optional['types.AgentMaxAggregateInput'] = None,
        having: Optional['types.AgentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AgentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AgentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AgentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AgentGroupByOutput']:
        """Group Agent records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Agent fields to group records by
        where
            Agent filter to select records
        take
            Limit the maximum number of Agent records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AgentGroupByOutput]
            A list of dictionaries representing the Agent record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Agent records by deploymentInfo values
        # and count how many records are in each group
        results = await Agent.prisma().group_by(
            ['deploymentInfo'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WorkflowActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Workflow]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Workflow.prisma().query_raw(
            'SELECT * FROM Workflow WHERE id = $1',
            'ghfhiafcb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Workflow
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Workflow.prisma().query_first(
            'SELECT * FROM Workflow WHERE agentId = $1',
            'heejgedji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WorkflowCreateInput,
        include: Optional[types.WorkflowInclude] = None
    ) -> _PrismaModelT:
        """Create a new Workflow record.

        Parameters
        ----------
        data
            Workflow record data
        include
            Specifies which relations should be loaded on the returned Workflow model

        Returns
        -------
        prisma.models.Workflow
            The created Workflow record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Workflow record from just the required fields
        workflow = await Workflow.prisma().create(
            data={
                # data to create a Workflow record
                'agentId': 'bjgjgibgbf',
                'name': 'bbbgbhfjge',
                'type': enums.WorkflowType.SEQUENTIAL,
                'definition': Json({'igbehcbab': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WorkflowCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Workflow records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Workflow record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Workflow.prisma().create_many(
            data=[
                {
                    # data to create a Workflow record
                    'agentId': 'bdadaadhag',
                    'name': 'bgiggdidbf',
                    'type': enums.WorkflowType.SEQUENTIAL,
                    'definition': Json({'caaaedabfc': True}),
                },
                {
                    # data to create a Workflow record
                    'agentId': 'bigibebcib',
                    'name': 'bigaiehgcc',
                    'type': enums.WorkflowType.SEQUENTIAL,
                    'definition': Json({'beeifcbebf': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WorkflowWhereUniqueInput,
        include: Optional[types.WorkflowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Workflow record.

        Parameters
        ----------
        where
            Workflow filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Workflow model

        Returns
        -------
        prisma.models.Workflow
            The deleted Workflow record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflow = await Workflow.prisma().delete(
            where={
                'id': 'bgcigfahea',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WorkflowWhereUniqueInput,
        include: Optional[types.WorkflowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Workflow record.

        Parameters
        ----------
        where
            Workflow filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Workflow model

        Returns
        -------
        prisma.models.Workflow
            The found Workflow record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflow = await Workflow.prisma().find_unique(
            where={
                'id': 'bcejgaggif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WorkflowWhereUniqueInput,
        include: Optional[types.WorkflowInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Workflow record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Workflow filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Workflow model

        Returns
        -------
        prisma.models.Workflow
            The found Workflow record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflow = await Workflow.prisma().find_unique_or_raise(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowWhereInput] = None,
        cursor: Optional[types.WorkflowWhereUniqueInput] = None,
        include: Optional[types.WorkflowInclude] = None,
        order: Optional[Union[types.WorkflowOrderByInput, List[types.WorkflowOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Workflow records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Workflow records returned
        skip
            Ignore the first N results
        where
            Workflow filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Workflow model
        order
            Order the returned Workflow records by any field
        distinct
            Filter Workflow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Workflow]
            The list of all Workflow records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Workflow records
        workflows = await Workflow.prisma().find_many(take=10)

        # find the first 5 Workflow records ordered by the name field
        workflows = await Workflow.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowWhereInput] = None,
        cursor: Optional[types.WorkflowWhereUniqueInput] = None,
        include: Optional[types.WorkflowInclude] = None,
        order: Optional[Union[types.WorkflowOrderByInput, List[types.WorkflowOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Workflow record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Workflow filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Workflow model
        order
            Order the returned Workflow records by any field
        distinct
            Filter Workflow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Workflow
            The first Workflow record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Workflow record ordered by the description field
        workflow = await Workflow.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowWhereInput] = None,
        cursor: Optional[types.WorkflowWhereUniqueInput] = None,
        include: Optional[types.WorkflowInclude] = None,
        order: Optional[Union[types.WorkflowOrderByInput, List[types.WorkflowOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Workflow record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Workflow filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Workflow model
        order
            Order the returned Workflow records by any field
        distinct
            Filter Workflow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Workflow
            The first Workflow record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Workflow record ordered by the type field
        workflow = await Workflow.prisma().find_first_or_raise(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WorkflowUpdateInput,
        where: types.WorkflowWhereUniqueInput,
        include: Optional[types.WorkflowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Workflow record.

        Parameters
        ----------
        data
            Workflow record data specifying what to update
        where
            Workflow filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Workflow model

        Returns
        -------
        prisma.models.Workflow
            The updated Workflow record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        workflow = await Workflow.prisma().update(
            where={
                'id': 'hgdhbjhhj',
            },
            data={
                # data to update the Workflow record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WorkflowWhereUniqueInput,
        data: types.WorkflowUpsertInput,
        include: Optional[types.WorkflowInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Workflow filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Workflow model

        Returns
        -------
        prisma.models.Workflow
            The created or updated Workflow record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflow = await Workflow.prisma().upsert(
            where={
                'id': 'ecjjjfbae',
            },
            data={
                'create': {
                    'id': 'ecjjjfbae',
                    'agentId': 'bigibebcib',
                    'name': 'bigaiehgcc',
                    'type': enums.WorkflowType.SEQUENTIAL,
                    'definition': Json({'beeifcbebf': True}),
                },
                'update': {
                    'agentId': 'bigibebcib',
                    'name': 'bigaiehgcc',
                    'type': enums.WorkflowType.SEQUENTIAL,
                    'definition': Json({'beeifcbebf': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WorkflowUpdateManyMutationInput,
        where: types.WorkflowWhereInput,
    ) -> int:
        """Update multiple Workflow records

        Parameters
        ----------
        data
            Workflow data to update the selected Workflow records to
        where
            Filter to select the Workflow records to update

        Returns
        -------
        int
            The total number of Workflow records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Workflow records
        total = await Workflow.prisma().update_many(
            data={
                'definition': Json({'bhhfibbigf': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowWhereInput] = None,
        cursor: Optional[types.WorkflowWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Workflow records present in the database

        Parameters
        ----------
        select
            Select the Workflow fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Workflow filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkflowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Workflow.prisma().count()

        # results: prisma.types.WorkflowCountAggregateOutput
        results = await Workflow.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WorkflowCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowWhereInput] = None,
        cursor: Optional[types.WorkflowWhereUniqueInput] = None,
    ) -> types.WorkflowCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WorkflowCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowWhereInput] = None,
        cursor: Optional[types.WorkflowWhereUniqueInput] = None,
    ) -> Union[int, types.WorkflowCountAggregateOutput]:
        """Count the number of Workflow records present in the database

        Parameters
        ----------
        select
            Select the Workflow fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Workflow filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkflowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Workflow.prisma().count()

        # results: prisma.types.WorkflowCountAggregateOutput
        results = await Workflow.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WorkflowCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WorkflowWhereInput] = None
    ) -> int:
        """Delete multiple Workflow records.

        Parameters
        ----------
        where
            Optional Workflow filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Workflow records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Workflow records
        total = await Workflow.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WorkflowScalarFieldKeys'],
        *,
        where: Optional['types.WorkflowWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WorkflowAvgAggregateInput'] = None,
        sum: Optional['types.WorkflowSumAggregateInput'] = None,
        min: Optional['types.WorkflowMinAggregateInput'] = None,
        max: Optional['types.WorkflowMaxAggregateInput'] = None,
        having: Optional['types.WorkflowScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WorkflowCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WorkflowScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WorkflowScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WorkflowGroupByOutput']:
        """Group Workflow records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Workflow fields to group records by
        where
            Workflow filter to select records
        take
            Limit the maximum number of Workflow records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WorkflowGroupByOutput]
            A list of dictionaries representing the Workflow record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Workflow records by updatedAt values
        # and count how many records are in each group
        results = await Workflow.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WorkflowExecutionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WorkflowExecution]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WorkflowExecution.prisma().query_raw(
            'SELECT * FROM WorkflowExecution WHERE id = $1',
            'ijdbeffgg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WorkflowExecution
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WorkflowExecution.prisma().query_first(
            'SELECT * FROM WorkflowExecution WHERE workflowId = $1',
            'jjfeafhfj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WorkflowExecutionCreateInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> _PrismaModelT:
        """Create a new WorkflowExecution record.

        Parameters
        ----------
        data
            WorkflowExecution record data
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The created WorkflowExecution record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WorkflowExecution record from just the required fields
        workflowexecution = await WorkflowExecution.prisma().create(
            data={
                # data to create a WorkflowExecution record
                'workflowId': 'cbachdgfce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WorkflowExecutionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WorkflowExecution records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WorkflowExecution record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WorkflowExecution.prisma().create_many(
            data=[
                {
                    # data to create a WorkflowExecution record
                    'workflowId': 'chbfcacbd',
                },
                {
                    # data to create a WorkflowExecution record
                    'workflowId': 'efggddide',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WorkflowExecution record.

        Parameters
        ----------
        where
            WorkflowExecution filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The deleted WorkflowExecution record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().delete(
            where={
                'id': 'caficfigfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WorkflowExecution record.

        Parameters
        ----------
        where
            WorkflowExecution filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The found WorkflowExecution record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().find_unique(
            where={
                'id': 'bfidgijfjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WorkflowExecution record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WorkflowExecution filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The found WorkflowExecution record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().find_unique_or_raise(
            where={
                'id': 'ihieecagf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
        include: Optional[types.WorkflowExecutionInclude] = None,
        order: Optional[Union[types.WorkflowExecutionOrderByInput, List[types.WorkflowExecutionOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowExecutionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WorkflowExecution records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WorkflowExecution records returned
        skip
            Ignore the first N results
        where
            WorkflowExecution filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model
        order
            Order the returned WorkflowExecution records by any field
        distinct
            Filter WorkflowExecution records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WorkflowExecution]
            The list of all WorkflowExecution records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WorkflowExecution records
        workflowexecutions = await WorkflowExecution.prisma().find_many(take=10)

        # find the first 5 WorkflowExecution records ordered by the status field
        workflowexecutions = await WorkflowExecution.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
        include: Optional[types.WorkflowExecutionInclude] = None,
        order: Optional[Union[types.WorkflowExecutionOrderByInput, List[types.WorkflowExecutionOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowExecutionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WorkflowExecution record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model
        order
            Order the returned WorkflowExecution records by any field
        distinct
            Filter WorkflowExecution records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WorkflowExecution
            The first WorkflowExecution record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WorkflowExecution record ordered by the parameters field
        workflowexecution = await WorkflowExecution.prisma().find_first(
            skip=1,
            order={
                'parameters': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
        include: Optional[types.WorkflowExecutionInclude] = None,
        order: Optional[Union[types.WorkflowExecutionOrderByInput, List[types.WorkflowExecutionOrderByInput]]] = None,
        distinct: Optional[List[types.WorkflowExecutionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WorkflowExecution record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model
        order
            Order the returned WorkflowExecution records by any field
        distinct
            Filter WorkflowExecution records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WorkflowExecution
            The first WorkflowExecution record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WorkflowExecution record ordered by the results field
        workflowexecution = await WorkflowExecution.prisma().find_first_or_raise(
            skip=1,
            order={
                'results': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WorkflowExecutionUpdateInput,
        where: types.WorkflowExecutionWhereUniqueInput,
        include: Optional[types.WorkflowExecutionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WorkflowExecution record.

        Parameters
        ----------
        data
            WorkflowExecution record data specifying what to update
        where
            WorkflowExecution filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The updated WorkflowExecution record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().update(
            where={
                'id': 'bghfciaafe',
            },
            data={
                # data to update the WorkflowExecution record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WorkflowExecutionWhereUniqueInput,
        data: types.WorkflowExecutionUpsertInput,
        include: Optional[types.WorkflowExecutionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WorkflowExecution filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WorkflowExecution model

        Returns
        -------
        prisma.models.WorkflowExecution
            The created or updated WorkflowExecution record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workflowexecution = await WorkflowExecution.prisma().upsert(
            where={
                'id': 'bgchfhgceh',
            },
            data={
                'create': {
                    'id': 'bgchfhgceh',
                    'workflowId': 'efggddide',
                },
                'update': {
                    'workflowId': 'efggddide',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WorkflowExecutionUpdateManyMutationInput,
        where: types.WorkflowExecutionWhereInput,
    ) -> int:
        """Update multiple WorkflowExecution records

        Parameters
        ----------
        data
            WorkflowExecution data to update the selected WorkflowExecution records to
        where
            Filter to select the WorkflowExecution records to update

        Returns
        -------
        int
            The total number of WorkflowExecution records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WorkflowExecution records
        total = await WorkflowExecution.prisma().update_many(
            data={
                'currentStep': 2054802212
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WorkflowExecution records present in the database

        Parameters
        ----------
        select
            Select the WorkflowExecution fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkflowExecutionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WorkflowExecution.prisma().count()

        # results: prisma.types.WorkflowExecutionCountAggregateOutput
        results = await WorkflowExecution.prisma().count(
            select={
                '_all': True,
                'startTime': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WorkflowExecutionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
    ) -> types.WorkflowExecutionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WorkflowExecutionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkflowExecutionWhereInput] = None,
        cursor: Optional[types.WorkflowExecutionWhereUniqueInput] = None,
    ) -> Union[int, types.WorkflowExecutionCountAggregateOutput]:
        """Count the number of WorkflowExecution records present in the database

        Parameters
        ----------
        select
            Select the WorkflowExecution fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WorkflowExecution filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkflowExecutionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WorkflowExecution.prisma().count()

        # results: prisma.types.WorkflowExecutionCountAggregateOutput
        results = await WorkflowExecution.prisma().count(
            select={
                '_all': True,
                'endTime': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WorkflowExecutionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WorkflowExecutionWhereInput] = None
    ) -> int:
        """Delete multiple WorkflowExecution records.

        Parameters
        ----------
        where
            Optional WorkflowExecution filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WorkflowExecution records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WorkflowExecution records
        total = await WorkflowExecution.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WorkflowExecutionScalarFieldKeys'],
        *,
        where: Optional['types.WorkflowExecutionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WorkflowExecutionAvgAggregateInput'] = None,
        sum: Optional['types.WorkflowExecutionSumAggregateInput'] = None,
        min: Optional['types.WorkflowExecutionMinAggregateInput'] = None,
        max: Optional['types.WorkflowExecutionMaxAggregateInput'] = None,
        having: Optional['types.WorkflowExecutionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WorkflowExecutionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WorkflowExecutionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WorkflowExecutionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WorkflowExecutionGroupByOutput']:
        """Group WorkflowExecution records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WorkflowExecution fields to group records by
        where
            WorkflowExecution filter to select records
        take
            Limit the maximum number of WorkflowExecution records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WorkflowExecutionGroupByOutput]
            A list of dictionaries representing the WorkflowExecution record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WorkflowExecution records by createdAt values
        # and count how many records are in each group
        results = await WorkflowExecution.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ToolActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tool]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tool.prisma().query_raw(
            'SELECT * FROM Tool WHERE id = $1',
            'gaddfhfh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tool
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tool.prisma().query_first(
            'SELECT * FROM Tool WHERE agentId = $1',
            'gieegcbeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ToolCreateInput,
        include: Optional[types.ToolInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tool record.

        Parameters
        ----------
        data
            Tool record data
        include
            Specifies which relations should be loaded on the returned Tool model

        Returns
        -------
        prisma.models.Tool
            The created Tool record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tool record from just the required fields
        tool = await Tool.prisma().create(
            data={
                # data to create a Tool record
                'agentId': 'bgcffadich',
                'name': 'fcbichhci',
                'functionSignature': Json({'bcggadccgf': True}),
                'connectionDetails': Json({'jdcfdcgc': True}),
                'securityPolicy': Json({'cafdaehjid': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ToolCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tool records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tool record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tool.prisma().create_many(
            data=[
                {
                    # data to create a Tool record
                    'agentId': 'gifdddbia',
                    'name': 'bchehecef',
                    'functionSignature': Json({'jeijcbhfe': True}),
                    'connectionDetails': Json({'bjgejjabff': True}),
                    'securityPolicy': Json({'bcciijbibg': True}),
                },
                {
                    # data to create a Tool record
                    'agentId': 'cffcachfd',
                    'name': 'bccdfhdigc',
                    'functionSignature': Json({'febcgjbfj': True}),
                    'connectionDetails': Json({'bageiegghg': True}),
                    'securityPolicy': Json({'faidicegb': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ToolWhereUniqueInput,
        include: Optional[types.ToolInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tool record.

        Parameters
        ----------
        where
            Tool filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tool model

        Returns
        -------
        prisma.models.Tool
            The deleted Tool record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tool = await Tool.prisma().delete(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ToolWhereUniqueInput,
        include: Optional[types.ToolInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tool record.

        Parameters
        ----------
        where
            Tool filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tool model

        Returns
        -------
        prisma.models.Tool
            The found Tool record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tool = await Tool.prisma().find_unique(
            where={
                'id': 'ihcahiead',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ToolWhereUniqueInput,
        include: Optional[types.ToolInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tool record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tool filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tool model

        Returns
        -------
        prisma.models.Tool
            The found Tool record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tool = await Tool.prisma().find_unique_or_raise(
            where={
                'id': 'biheheiajg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolWhereInput] = None,
        cursor: Optional[types.ToolWhereUniqueInput] = None,
        include: Optional[types.ToolInclude] = None,
        order: Optional[Union[types.ToolOrderByInput, List[types.ToolOrderByInput]]] = None,
        distinct: Optional[List[types.ToolScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tool records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tool records returned
        skip
            Ignore the first N results
        where
            Tool filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tool model
        order
            Order the returned Tool records by any field
        distinct
            Filter Tool records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tool]
            The list of all Tool records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tool records
        tools = await Tool.prisma().find_many(take=10)

        # find the first 5 Tool records ordered by the name field
        tools = await Tool.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ToolWhereInput] = None,
        cursor: Optional[types.ToolWhereUniqueInput] = None,
        include: Optional[types.ToolInclude] = None,
        order: Optional[Union[types.ToolOrderByInput, List[types.ToolOrderByInput]]] = None,
        distinct: Optional[List[types.ToolScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tool record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tool filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tool model
        order
            Order the returned Tool records by any field
        distinct
            Filter Tool records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tool
            The first Tool record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tool record ordered by the description field
        tool = await Tool.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ToolWhereInput] = None,
        cursor: Optional[types.ToolWhereUniqueInput] = None,
        include: Optional[types.ToolInclude] = None,
        order: Optional[Union[types.ToolOrderByInput, List[types.ToolOrderByInput]]] = None,
        distinct: Optional[List[types.ToolScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tool record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tool filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tool model
        order
            Order the returned Tool records by any field
        distinct
            Filter Tool records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tool
            The first Tool record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tool record ordered by the functionSignature field
        tool = await Tool.prisma().find_first_or_raise(
            skip=1,
            order={
                'functionSignature': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ToolUpdateInput,
        where: types.ToolWhereUniqueInput,
        include: Optional[types.ToolInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tool record.

        Parameters
        ----------
        data
            Tool record data specifying what to update
        where
            Tool filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tool model

        Returns
        -------
        prisma.models.Tool
            The updated Tool record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tool = await Tool.prisma().update(
            where={
                'id': 'jbgijghgb',
            },
            data={
                # data to update the Tool record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ToolWhereUniqueInput,
        data: types.ToolUpsertInput,
        include: Optional[types.ToolInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tool filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tool model

        Returns
        -------
        prisma.models.Tool
            The created or updated Tool record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tool = await Tool.prisma().upsert(
            where={
                'id': 'hgjcghfbi',
            },
            data={
                'create': {
                    'id': 'hgjcghfbi',
                    'agentId': 'cffcachfd',
                    'name': 'bccdfhdigc',
                    'functionSignature': Json({'febcgjbfj': True}),
                    'connectionDetails': Json({'bageiegghg': True}),
                    'securityPolicy': Json({'faidicegb': True}),
                },
                'update': {
                    'agentId': 'cffcachfd',
                    'name': 'bccdfhdigc',
                    'functionSignature': Json({'febcgjbfj': True}),
                    'connectionDetails': Json({'bageiegghg': True}),
                    'securityPolicy': Json({'faidicegb': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ToolUpdateManyMutationInput,
        where: types.ToolWhereInput,
    ) -> int:
        """Update multiple Tool records

        Parameters
        ----------
        data
            Tool data to update the selected Tool records to
        where
            Filter to select the Tool records to update

        Returns
        -------
        int
            The total number of Tool records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tool records
        total = await Tool.prisma().update_many(
            data={
                'connectionDetails': Json({'icadbcehj': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolWhereInput] = None,
        cursor: Optional[types.ToolWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tool records present in the database

        Parameters
        ----------
        select
            Select the Tool fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tool filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ToolCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tool.prisma().count()

        # results: prisma.types.ToolCountAggregateOutput
        results = await Tool.prisma().count(
            select={
                '_all': True,
                'securityPolicy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ToolCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolWhereInput] = None,
        cursor: Optional[types.ToolWhereUniqueInput] = None,
    ) -> types.ToolCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ToolCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolWhereInput] = None,
        cursor: Optional[types.ToolWhereUniqueInput] = None,
    ) -> Union[int, types.ToolCountAggregateOutput]:
        """Count the number of Tool records present in the database

        Parameters
        ----------
        select
            Select the Tool fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tool filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ToolCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tool.prisma().count()

        # results: prisma.types.ToolCountAggregateOutput
        results = await Tool.prisma().count(
            select={
                '_all': True,
                'mcpServerId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ToolCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ToolWhereInput] = None
    ) -> int:
        """Delete multiple Tool records.

        Parameters
        ----------
        where
            Optional Tool filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tool records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tool records
        total = await Tool.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ToolScalarFieldKeys'],
        *,
        where: Optional['types.ToolWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ToolAvgAggregateInput'] = None,
        sum: Optional['types.ToolSumAggregateInput'] = None,
        min: Optional['types.ToolMinAggregateInput'] = None,
        max: Optional['types.ToolMaxAggregateInput'] = None,
        having: Optional['types.ToolScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ToolCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ToolScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ToolScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ToolGroupByOutput']:
        """Group Tool records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tool fields to group records by
        where
            Tool filter to select records
        take
            Limit the maximum number of Tool records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ToolGroupByOutput]
            A list of dictionaries representing the Tool record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tool records by status values
        # and count how many records are in each group
        results = await Tool.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ToolInvocationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ToolInvocation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ToolInvocation.prisma().query_raw(
            'SELECT * FROM ToolInvocation WHERE id = $1',
            'jchciaee',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ToolInvocation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ToolInvocation.prisma().query_first(
            'SELECT * FROM ToolInvocation WHERE toolId = $1',
            'deeificjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ToolInvocationCreateInput,
        include: Optional[types.ToolInvocationInclude] = None
    ) -> _PrismaModelT:
        """Create a new ToolInvocation record.

        Parameters
        ----------
        data
            ToolInvocation record data
        include
            Specifies which relations should be loaded on the returned ToolInvocation model

        Returns
        -------
        prisma.models.ToolInvocation
            The created ToolInvocation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ToolInvocation record from just the required fields
        toolinvocation = await ToolInvocation.prisma().create(
            data={
                # data to create a ToolInvocation record
                'toolId': 'bbcbhebbda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ToolInvocationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ToolInvocation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ToolInvocation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ToolInvocation.prisma().create_many(
            data=[
                {
                    # data to create a ToolInvocation record
                    'toolId': 'bejfijgcfb',
                },
                {
                    # data to create a ToolInvocation record
                    'toolId': 'caifcbgii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ToolInvocationWhereUniqueInput,
        include: Optional[types.ToolInvocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ToolInvocation record.

        Parameters
        ----------
        where
            ToolInvocation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ToolInvocation model

        Returns
        -------
        prisma.models.ToolInvocation
            The deleted ToolInvocation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        toolinvocation = await ToolInvocation.prisma().delete(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ToolInvocationWhereUniqueInput,
        include: Optional[types.ToolInvocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ToolInvocation record.

        Parameters
        ----------
        where
            ToolInvocation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ToolInvocation model

        Returns
        -------
        prisma.models.ToolInvocation
            The found ToolInvocation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        toolinvocation = await ToolInvocation.prisma().find_unique(
            where={
                'id': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ToolInvocationWhereUniqueInput,
        include: Optional[types.ToolInvocationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ToolInvocation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ToolInvocation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ToolInvocation model

        Returns
        -------
        prisma.models.ToolInvocation
            The found ToolInvocation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        toolinvocation = await ToolInvocation.prisma().find_unique_or_raise(
            where={
                'id': 'fcfhgbjed',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolInvocationWhereInput] = None,
        cursor: Optional[types.ToolInvocationWhereUniqueInput] = None,
        include: Optional[types.ToolInvocationInclude] = None,
        order: Optional[Union[types.ToolInvocationOrderByInput, List[types.ToolInvocationOrderByInput]]] = None,
        distinct: Optional[List[types.ToolInvocationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ToolInvocation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ToolInvocation records returned
        skip
            Ignore the first N results
        where
            ToolInvocation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ToolInvocation model
        order
            Order the returned ToolInvocation records by any field
        distinct
            Filter ToolInvocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ToolInvocation]
            The list of all ToolInvocation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ToolInvocation records
        toolinvocations = await ToolInvocation.prisma().find_many(take=10)

        # find the first 5 ToolInvocation records ordered by the parameters field
        toolinvocations = await ToolInvocation.prisma().find_many(
            take=5,
            order={
                'parameters': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ToolInvocationWhereInput] = None,
        cursor: Optional[types.ToolInvocationWhereUniqueInput] = None,
        include: Optional[types.ToolInvocationInclude] = None,
        order: Optional[Union[types.ToolInvocationOrderByInput, List[types.ToolInvocationOrderByInput]]] = None,
        distinct: Optional[List[types.ToolInvocationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ToolInvocation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ToolInvocation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ToolInvocation model
        order
            Order the returned ToolInvocation records by any field
        distinct
            Filter ToolInvocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ToolInvocation
            The first ToolInvocation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ToolInvocation record ordered by the context field
        toolinvocation = await ToolInvocation.prisma().find_first(
            skip=1,
            order={
                'context': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ToolInvocationWhereInput] = None,
        cursor: Optional[types.ToolInvocationWhereUniqueInput] = None,
        include: Optional[types.ToolInvocationInclude] = None,
        order: Optional[Union[types.ToolInvocationOrderByInput, List[types.ToolInvocationOrderByInput]]] = None,
        distinct: Optional[List[types.ToolInvocationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ToolInvocation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ToolInvocation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ToolInvocation model
        order
            Order the returned ToolInvocation records by any field
        distinct
            Filter ToolInvocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ToolInvocation
            The first ToolInvocation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ToolInvocation record ordered by the result field
        toolinvocation = await ToolInvocation.prisma().find_first_or_raise(
            skip=1,
            order={
                'result': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ToolInvocationUpdateInput,
        where: types.ToolInvocationWhereUniqueInput,
        include: Optional[types.ToolInvocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ToolInvocation record.

        Parameters
        ----------
        data
            ToolInvocation record data specifying what to update
        where
            ToolInvocation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ToolInvocation model

        Returns
        -------
        prisma.models.ToolInvocation
            The updated ToolInvocation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        toolinvocation = await ToolInvocation.prisma().update(
            where={
                'id': 'hdgcajhjg',
            },
            data={
                # data to update the ToolInvocation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ToolInvocationWhereUniqueInput,
        data: types.ToolInvocationUpsertInput,
        include: Optional[types.ToolInvocationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ToolInvocation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ToolInvocation model

        Returns
        -------
        prisma.models.ToolInvocation
            The created or updated ToolInvocation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        toolinvocation = await ToolInvocation.prisma().upsert(
            where={
                'id': 'ejdjahicb',
            },
            data={
                'create': {
                    'id': 'ejdjahicb',
                    'toolId': 'caifcbgii',
                },
                'update': {
                    'toolId': 'caifcbgii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ToolInvocationUpdateManyMutationInput,
        where: types.ToolInvocationWhereInput,
    ) -> int:
        """Update multiple ToolInvocation records

        Parameters
        ----------
        data
            ToolInvocation data to update the selected ToolInvocation records to
        where
            Filter to select the ToolInvocation records to update

        Returns
        -------
        int
            The total number of ToolInvocation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ToolInvocation records
        total = await ToolInvocation.prisma().update_many(
            data={
                'status': 'gdjgigfgc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolInvocationWhereInput] = None,
        cursor: Optional[types.ToolInvocationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ToolInvocation records present in the database

        Parameters
        ----------
        select
            Select the ToolInvocation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ToolInvocation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ToolInvocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ToolInvocation.prisma().count()

        # results: prisma.types.ToolInvocationCountAggregateOutput
        results = await ToolInvocation.prisma().count(
            select={
                '_all': True,
                'duration': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ToolInvocationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolInvocationWhereInput] = None,
        cursor: Optional[types.ToolInvocationWhereUniqueInput] = None,
    ) -> types.ToolInvocationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ToolInvocationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ToolInvocationWhereInput] = None,
        cursor: Optional[types.ToolInvocationWhereUniqueInput] = None,
    ) -> Union[int, types.ToolInvocationCountAggregateOutput]:
        """Count the number of ToolInvocation records present in the database

        Parameters
        ----------
        select
            Select the ToolInvocation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ToolInvocation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ToolInvocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ToolInvocation.prisma().count()

        # results: prisma.types.ToolInvocationCountAggregateOutput
        results = await ToolInvocation.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ToolInvocationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ToolInvocationWhereInput] = None
    ) -> int:
        """Delete multiple ToolInvocation records.

        Parameters
        ----------
        where
            Optional ToolInvocation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ToolInvocation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ToolInvocation records
        total = await ToolInvocation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ToolInvocationScalarFieldKeys'],
        *,
        where: Optional['types.ToolInvocationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ToolInvocationAvgAggregateInput'] = None,
        sum: Optional['types.ToolInvocationSumAggregateInput'] = None,
        min: Optional['types.ToolInvocationMinAggregateInput'] = None,
        max: Optional['types.ToolInvocationMaxAggregateInput'] = None,
        having: Optional['types.ToolInvocationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ToolInvocationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ToolInvocationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ToolInvocationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ToolInvocationGroupByOutput']:
        """Group ToolInvocation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ToolInvocation fields to group records by
        where
            ToolInvocation filter to select records
        take
            Limit the maximum number of ToolInvocation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ToolInvocationGroupByOutput]
            A list of dictionaries representing the ToolInvocation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ToolInvocation records by completedAt values
        # and count how many records are in each group
        results = await ToolInvocation.prisma().group_by(
            ['completedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConversationSessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ConversationSession]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ConversationSession.prisma().query_raw(
            'SELECT * FROM ConversationSession WHERE id = $1',
            'gfeaahdeh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ConversationSession
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ConversationSession.prisma().query_first(
            'SELECT * FROM ConversationSession WHERE agentId = $1',
            'bjafcgbffc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ConversationSessionCreateInput,
        include: Optional[types.ConversationSessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new ConversationSession record.

        Parameters
        ----------
        data
            ConversationSession record data
        include
            Specifies which relations should be loaded on the returned ConversationSession model

        Returns
        -------
        prisma.models.ConversationSession
            The created ConversationSession record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ConversationSession record from just the required fields
        conversationsession = await ConversationSession.prisma().create(
            data={
                # data to create a ConversationSession record
                'agentId': 'hihegjif',
                'userId': 'bdjidcidac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConversationSessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ConversationSession records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ConversationSession record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ConversationSession.prisma().create_many(
            data=[
                {
                    # data to create a ConversationSession record
                    'agentId': 'ifgaaagff',
                    'userId': 'befcddgjce',
                },
                {
                    # data to create a ConversationSession record
                    'agentId': 'bfhdbjjgfd',
                    'userId': 'cabdjadaji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConversationSessionWhereUniqueInput,
        include: Optional[types.ConversationSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ConversationSession record.

        Parameters
        ----------
        where
            ConversationSession filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationSession model

        Returns
        -------
        prisma.models.ConversationSession
            The deleted ConversationSession record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsession = await ConversationSession.prisma().delete(
            where={
                'id': 'faajgfadf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConversationSessionWhereUniqueInput,
        include: Optional[types.ConversationSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ConversationSession record.

        Parameters
        ----------
        where
            ConversationSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationSession model

        Returns
        -------
        prisma.models.ConversationSession
            The found ConversationSession record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsession = await ConversationSession.prisma().find_unique(
            where={
                'id': 'biaagcedjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConversationSessionWhereUniqueInput,
        include: Optional[types.ConversationSessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ConversationSession record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ConversationSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationSession model

        Returns
        -------
        prisma.models.ConversationSession
            The found ConversationSession record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsession = await ConversationSession.prisma().find_unique_or_raise(
            where={
                'id': 'cahhaghecf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationSessionWhereInput] = None,
        cursor: Optional[types.ConversationSessionWhereUniqueInput] = None,
        include: Optional[types.ConversationSessionInclude] = None,
        order: Optional[Union[types.ConversationSessionOrderByInput, List[types.ConversationSessionOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationSessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ConversationSession records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ConversationSession records returned
        skip
            Ignore the first N results
        where
            ConversationSession filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationSession model
        order
            Order the returned ConversationSession records by any field
        distinct
            Filter ConversationSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ConversationSession]
            The list of all ConversationSession records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ConversationSession records
        conversationsessions = await ConversationSession.prisma().find_many(take=10)

        # find the first 5 ConversationSession records ordered by the userId field
        conversationsessions = await ConversationSession.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationSessionWhereInput] = None,
        cursor: Optional[types.ConversationSessionWhereUniqueInput] = None,
        include: Optional[types.ConversationSessionInclude] = None,
        order: Optional[Union[types.ConversationSessionOrderByInput, List[types.ConversationSessionOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationSessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ConversationSession record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationSession model
        order
            Order the returned ConversationSession records by any field
        distinct
            Filter ConversationSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationSession
            The first ConversationSession record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationSession record ordered by the status field
        conversationsession = await ConversationSession.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationSessionWhereInput] = None,
        cursor: Optional[types.ConversationSessionWhereUniqueInput] = None,
        include: Optional[types.ConversationSessionInclude] = None,
        order: Optional[Union[types.ConversationSessionOrderByInput, List[types.ConversationSessionOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationSessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ConversationSession record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationSession model
        order
            Order the returned ConversationSession records by any field
        distinct
            Filter ConversationSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationSession
            The first ConversationSession record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationSession record ordered by the context field
        conversationsession = await ConversationSession.prisma().find_first_or_raise(
            skip=1,
            order={
                'context': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConversationSessionUpdateInput,
        where: types.ConversationSessionWhereUniqueInput,
        include: Optional[types.ConversationSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ConversationSession record.

        Parameters
        ----------
        data
            ConversationSession record data specifying what to update
        where
            ConversationSession filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ConversationSession model

        Returns
        -------
        prisma.models.ConversationSession
            The updated ConversationSession record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conversationsession = await ConversationSession.prisma().update(
            where={
                'id': 'bghcbbcidi',
            },
            data={
                # data to update the ConversationSession record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConversationSessionWhereUniqueInput,
        data: types.ConversationSessionUpsertInput,
        include: Optional[types.ConversationSessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ConversationSession filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ConversationSession model

        Returns
        -------
        prisma.models.ConversationSession
            The created or updated ConversationSession record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationsession = await ConversationSession.prisma().upsert(
            where={
                'id': 'jcgghhgdj',
            },
            data={
                'create': {
                    'id': 'jcgghhgdj',
                    'agentId': 'bfhdbjjgfd',
                    'userId': 'cabdjadaji',
                },
                'update': {
                    'agentId': 'bfhdbjjgfd',
                    'userId': 'cabdjadaji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConversationSessionUpdateManyMutationInput,
        where: types.ConversationSessionWhereInput,
    ) -> int:
        """Update multiple ConversationSession records

        Parameters
        ----------
        data
            ConversationSession data to update the selected ConversationSession records to
        where
            Filter to select the ConversationSession records to update

        Returns
        -------
        int
            The total number of ConversationSession records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ConversationSession records
        total = await ConversationSession.prisma().update_many(
            data={
                'metadata': Json({'beehgcebbg': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationSessionWhereInput] = None,
        cursor: Optional[types.ConversationSessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ConversationSession records present in the database

        Parameters
        ----------
        select
            Select the ConversationSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationSession.prisma().count()

        # results: prisma.types.ConversationSessionCountAggregateOutput
        results = await ConversationSession.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConversationSessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationSessionWhereInput] = None,
        cursor: Optional[types.ConversationSessionWhereUniqueInput] = None,
    ) -> types.ConversationSessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConversationSessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationSessionWhereInput] = None,
        cursor: Optional[types.ConversationSessionWhereUniqueInput] = None,
    ) -> Union[int, types.ConversationSessionCountAggregateOutput]:
        """Count the number of ConversationSession records present in the database

        Parameters
        ----------
        select
            Select the ConversationSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationSession.prisma().count()

        # results: prisma.types.ConversationSessionCountAggregateOutput
        results = await ConversationSession.prisma().count(
            select={
                '_all': True,
                'lastActivity': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConversationSessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConversationSessionWhereInput] = None
    ) -> int:
        """Delete multiple ConversationSession records.

        Parameters
        ----------
        where
            Optional ConversationSession filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ConversationSession records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ConversationSession records
        total = await ConversationSession.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConversationSessionScalarFieldKeys'],
        *,
        where: Optional['types.ConversationSessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConversationSessionAvgAggregateInput'] = None,
        sum: Optional['types.ConversationSessionSumAggregateInput'] = None,
        min: Optional['types.ConversationSessionMinAggregateInput'] = None,
        max: Optional['types.ConversationSessionMaxAggregateInput'] = None,
        having: Optional['types.ConversationSessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConversationSessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConversationSessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ConversationSessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ConversationSessionGroupByOutput']:
        """Group ConversationSession records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ConversationSession fields to group records by
        where
            ConversationSession filter to select records
        take
            Limit the maximum number of ConversationSession records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConversationSessionGroupByOutput]
            A list of dictionaries representing the ConversationSession record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ConversationSession records by id values
        # and count how many records are in each group
        results = await ConversationSession.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Message]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Message.prisma().query_raw(
            'SELECT * FROM Message WHERE id = $1',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Message
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Message.prisma().query_first(
            'SELECT * FROM Message WHERE sessionId = $1',
            'deajegcfi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MessageCreateInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Message record.

        Parameters
        ----------
        data
            Message record data
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created Message record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Message record from just the required fields
        message = await Message.prisma().create(
            data={
                # data to create a Message record
                'sessionId': 'gabahhhjf',
                'role': enums.MessageRole.USER,
                'content': 'cjagadcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Message records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Message record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Message.prisma().create_many(
            data=[
                {
                    # data to create a Message record
                    'sessionId': 'bifficggej',
                    'role': enums.MessageRole.USER,
                    'content': 'bgbbaajbic',
                },
                {
                    # data to create a Message record
                    'sessionId': 'eegghdhjb',
                    'role': enums.MessageRole.USER,
                    'content': 'daafgidjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Message record.

        Parameters
        ----------
        where
            Message filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The deleted Message record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().delete(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Message record.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Message record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique_or_raise(
            where={
                'id': 'ehabfhegh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Message records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N results
        where
            Message filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Message]
            The list of all Message records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Message records
        messages = await Message.prisma().find_many(take=10)

        # find the first 5 Message records ordered by the role field
        messages = await Message.prisma().find_many(
            take=5,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Message record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the content field
        message = await Message.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Message record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the metadata field
        message = await Message.prisma().find_first_or_raise(
            skip=1,
            order={
                'metadata': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageUpdateInput,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Message record.

        Parameters
        ----------
        data
            Message record data specifying what to update
        where
            Message filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The updated Message record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message = await Message.prisma().update(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                # data to update the Message record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageWhereUniqueInput,
        data: types.MessageUpsertInput,
        include: Optional[types.MessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Message filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created or updated Message record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().upsert(
            where={
                'id': 'bfdgheeegf',
            },
            data={
                'create': {
                    'id': 'bfdgheeegf',
                    'sessionId': 'eegghdhjb',
                    'role': enums.MessageRole.USER,
                    'content': 'daafgidjg',
                },
                'update': {
                    'sessionId': 'eegghdhjb',
                    'role': enums.MessageRole.USER,
                    'content': 'daafgidjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageUpdateManyMutationInput,
        where: types.MessageWhereInput,
    ) -> int:
        """Update multiple Message records

        Parameters
        ----------
        data
            Message data to update the selected Message records to
        where
            Filter to select the Message records to update

        Returns
        -------
        int
            The total number of Message records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Message records
        total = await Message.prisma().update_many(
            data={
                'toolCalls': Json({'ececbijji': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> types.MessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> Union[int, types.MessageCountAggregateOutput]:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageWhereInput] = None
    ) -> int:
        """Delete multiple Message records.

        Parameters
        ----------
        where
            Optional Message filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Message records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Message records
        total = await Message.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageScalarFieldKeys'],
        *,
        where: Optional['types.MessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageAvgAggregateInput'] = None,
        sum: Optional['types.MessageSumAggregateInput'] = None,
        min: Optional['types.MessageMinAggregateInput'] = None,
        max: Optional['types.MessageMaxAggregateInput'] = None,
        having: Optional['types.MessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageGroupByOutput']:
        """Group Message records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Message fields to group records by
        where
            Message filter to select records
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageGroupByOutput]
            A list of dictionaries representing the Message record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Message records by sessionId values
        # and count how many records are in each group
        results = await Message.prisma().group_by(
            ['sessionId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VectorStoreActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.VectorStore]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await VectorStore.prisma().query_raw(
            'SELECT * FROM VectorStore WHERE id = $1',
            'cbcfgdcdhf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.VectorStore
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await VectorStore.prisma().query_first(
            'SELECT * FROM VectorStore WHERE name = $1',
            'fdgjfbhia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VectorStoreCreateInput,
        include: Optional[types.VectorStoreInclude] = None
    ) -> _PrismaModelT:
        """Create a new VectorStore record.

        Parameters
        ----------
        data
            VectorStore record data
        include
            Specifies which relations should be loaded on the returned VectorStore model

        Returns
        -------
        prisma.models.VectorStore
            The created VectorStore record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a VectorStore record from just the required fields
        vectorstore = await VectorStore.prisma().create(
            data={
                # data to create a VectorStore record
                'name': 'jcehcdchh',
                'type': enums.VectorStoreType.VERTEX_AI,
                'configuration': Json({'bgcbjdhjcc': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VectorStoreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple VectorStore records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of VectorStore record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await VectorStore.prisma().create_many(
            data=[
                {
                    # data to create a VectorStore record
                    'name': 'bieiidcabj',
                    'type': enums.VectorStoreType.VERTEX_AI,
                    'configuration': Json({'bjcbfcieaa': True}),
                },
                {
                    # data to create a VectorStore record
                    'name': 'cbaaechiej',
                    'type': enums.VectorStoreType.VERTEX_AI,
                    'configuration': Json({'iejbeaaeg': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VectorStoreWhereUniqueInput,
        include: Optional[types.VectorStoreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single VectorStore record.

        Parameters
        ----------
        where
            VectorStore filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned VectorStore model

        Returns
        -------
        prisma.models.VectorStore
            The deleted VectorStore record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vectorstore = await VectorStore.prisma().delete(
            where={
                'id': 'jcibfcbhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VectorStoreWhereUniqueInput,
        include: Optional[types.VectorStoreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique VectorStore record.

        Parameters
        ----------
        where
            VectorStore filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VectorStore model

        Returns
        -------
        prisma.models.VectorStore
            The found VectorStore record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vectorstore = await VectorStore.prisma().find_unique(
            where={
                'id': 'chdadcaga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VectorStoreWhereUniqueInput,
        include: Optional[types.VectorStoreInclude] = None
    ) -> _PrismaModelT:
        """Find a unique VectorStore record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            VectorStore filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VectorStore model

        Returns
        -------
        prisma.models.VectorStore
            The found VectorStore record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vectorstore = await VectorStore.prisma().find_unique_or_raise(
            where={
                'id': 'jicieifbh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VectorStoreWhereInput] = None,
        cursor: Optional[types.VectorStoreWhereUniqueInput] = None,
        include: Optional[types.VectorStoreInclude] = None,
        order: Optional[Union[types.VectorStoreOrderByInput, List[types.VectorStoreOrderByInput]]] = None,
        distinct: Optional[List[types.VectorStoreScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple VectorStore records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of VectorStore records returned
        skip
            Ignore the first N results
        where
            VectorStore filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VectorStore model
        order
            Order the returned VectorStore records by any field
        distinct
            Filter VectorStore records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.VectorStore]
            The list of all VectorStore records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 VectorStore records
        vectorstores = await VectorStore.prisma().find_many(take=10)

        # find the first 5 VectorStore records ordered by the type field
        vectorstores = await VectorStore.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VectorStoreWhereInput] = None,
        cursor: Optional[types.VectorStoreWhereUniqueInput] = None,
        include: Optional[types.VectorStoreInclude] = None,
        order: Optional[Union[types.VectorStoreOrderByInput, List[types.VectorStoreOrderByInput]]] = None,
        distinct: Optional[List[types.VectorStoreScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single VectorStore record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VectorStore filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VectorStore model
        order
            Order the returned VectorStore records by any field
        distinct
            Filter VectorStore records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VectorStore
            The first VectorStore record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VectorStore record ordered by the configuration field
        vectorstore = await VectorStore.prisma().find_first(
            skip=1,
            order={
                'configuration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VectorStoreWhereInput] = None,
        cursor: Optional[types.VectorStoreWhereUniqueInput] = None,
        include: Optional[types.VectorStoreInclude] = None,
        order: Optional[Union[types.VectorStoreOrderByInput, List[types.VectorStoreOrderByInput]]] = None,
        distinct: Optional[List[types.VectorStoreScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single VectorStore record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VectorStore filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VectorStore model
        order
            Order the returned VectorStore records by any field
        distinct
            Filter VectorStore records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VectorStore
            The first VectorStore record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VectorStore record ordered by the status field
        vectorstore = await VectorStore.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VectorStoreUpdateInput,
        where: types.VectorStoreWhereUniqueInput,
        include: Optional[types.VectorStoreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single VectorStore record.

        Parameters
        ----------
        data
            VectorStore record data specifying what to update
        where
            VectorStore filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned VectorStore model

        Returns
        -------
        prisma.models.VectorStore
            The updated VectorStore record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vectorstore = await VectorStore.prisma().update(
            where={
                'id': 'fbahdheji',
            },
            data={
                # data to update the VectorStore record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VectorStoreWhereUniqueInput,
        data: types.VectorStoreUpsertInput,
        include: Optional[types.VectorStoreInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            VectorStore filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned VectorStore model

        Returns
        -------
        prisma.models.VectorStore
            The created or updated VectorStore record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vectorstore = await VectorStore.prisma().upsert(
            where={
                'id': 'cbbheiicgh',
            },
            data={
                'create': {
                    'id': 'cbbheiicgh',
                    'name': 'cbaaechiej',
                    'type': enums.VectorStoreType.VERTEX_AI,
                    'configuration': Json({'iejbeaaeg': True}),
                },
                'update': {
                    'name': 'cbaaechiej',
                    'type': enums.VectorStoreType.VERTEX_AI,
                    'configuration': Json({'iejbeaaeg': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VectorStoreUpdateManyMutationInput,
        where: types.VectorStoreWhereInput,
    ) -> int:
        """Update multiple VectorStore records

        Parameters
        ----------
        data
            VectorStore data to update the selected VectorStore records to
        where
            Filter to select the VectorStore records to update

        Returns
        -------
        int
            The total number of VectorStore records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all VectorStore records
        total = await VectorStore.prisma().update_many(
            data={
                'statistics': Json({'beabjeejdg': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VectorStoreWhereInput] = None,
        cursor: Optional[types.VectorStoreWhereUniqueInput] = None,
    ) -> int:
        """Count the number of VectorStore records present in the database

        Parameters
        ----------
        select
            Select the VectorStore fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VectorStore filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VectorStoreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VectorStore.prisma().count()

        # results: prisma.types.VectorStoreCountAggregateOutput
        results = await VectorStore.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VectorStoreCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VectorStoreWhereInput] = None,
        cursor: Optional[types.VectorStoreWhereUniqueInput] = None,
    ) -> types.VectorStoreCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VectorStoreCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VectorStoreWhereInput] = None,
        cursor: Optional[types.VectorStoreWhereUniqueInput] = None,
    ) -> Union[int, types.VectorStoreCountAggregateOutput]:
        """Count the number of VectorStore records present in the database

        Parameters
        ----------
        select
            Select the VectorStore fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VectorStore filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VectorStoreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VectorStore.prisma().count()

        # results: prisma.types.VectorStoreCountAggregateOutput
        results = await VectorStore.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VectorStoreCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VectorStoreWhereInput] = None
    ) -> int:
        """Delete multiple VectorStore records.

        Parameters
        ----------
        where
            Optional VectorStore filter to find the records to be deleted

        Returns
        -------
        int
            The total number of VectorStore records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all VectorStore records
        total = await VectorStore.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VectorStoreScalarFieldKeys'],
        *,
        where: Optional['types.VectorStoreWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VectorStoreAvgAggregateInput'] = None,
        sum: Optional['types.VectorStoreSumAggregateInput'] = None,
        min: Optional['types.VectorStoreMinAggregateInput'] = None,
        max: Optional['types.VectorStoreMaxAggregateInput'] = None,
        having: Optional['types.VectorStoreScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VectorStoreCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VectorStoreScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VectorStoreScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VectorStoreGroupByOutput']:
        """Group VectorStore records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar VectorStore fields to group records by
        where
            VectorStore filter to select records
        take
            Limit the maximum number of VectorStore records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VectorStoreGroupByOutput]
            A list of dictionaries representing the VectorStore record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group VectorStore records by id values
        # and count how many records are in each group
        results = await VectorStore.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmbeddingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Embedding]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Embedding.prisma().query_raw(
            'SELECT * FROM Embedding WHERE id = $1',
            'bcjhgahffd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Embedding
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Embedding.prisma().query_first(
            'SELECT * FROM Embedding WHERE vectorStoreId = $1',
            'fbjeiiffa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmbeddingCreateInput,
        include: Optional[types.EmbeddingInclude] = None
    ) -> _PrismaModelT:
        """Create a new Embedding record.

        Parameters
        ----------
        data
            Embedding record data
        include
            Specifies which relations should be loaded on the returned Embedding model

        Returns
        -------
        prisma.models.Embedding
            The created Embedding record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Embedding record from just the required fields
        embedding = await Embedding.prisma().create(
            data={
                # data to create a Embedding record
                'vectorStoreId': 'jhgidcgbf',
                'documentId': 'bgjgecfejc',
                'chunkIndex': 169262781,
                'content': 'bacdaibgfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmbeddingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Embedding records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Embedding record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Embedding.prisma().create_many(
            data=[
                {
                    # data to create a Embedding record
                    'vectorStoreId': 'dchgibach',
                    'documentId': 'fchheijjc',
                    'chunkIndex': 2029357497,
                    'content': 'bdbifjhbbi',
                },
                {
                    # data to create a Embedding record
                    'vectorStoreId': 'cbccbbcdfb',
                    'documentId': 'bacejedaca',
                    'chunkIndex': 1717307509,
                    'content': 'bfjibceaec',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmbeddingWhereUniqueInput,
        include: Optional[types.EmbeddingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Embedding record.

        Parameters
        ----------
        where
            Embedding filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Embedding model

        Returns
        -------
        prisma.models.Embedding
            The deleted Embedding record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        embedding = await Embedding.prisma().delete(
            where={
                'id': 'ibhgcdbgd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmbeddingWhereUniqueInput,
        include: Optional[types.EmbeddingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Embedding record.

        Parameters
        ----------
        where
            Embedding filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Embedding model

        Returns
        -------
        prisma.models.Embedding
            The found Embedding record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        embedding = await Embedding.prisma().find_unique(
            where={
                'id': 'badaffhddg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmbeddingWhereUniqueInput,
        include: Optional[types.EmbeddingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Embedding record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Embedding filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Embedding model

        Returns
        -------
        prisma.models.Embedding
            The found Embedding record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        embedding = await Embedding.prisma().find_unique_or_raise(
            where={
                'id': 'bbdbfcfihd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmbeddingWhereInput] = None,
        cursor: Optional[types.EmbeddingWhereUniqueInput] = None,
        include: Optional[types.EmbeddingInclude] = None,
        order: Optional[Union[types.EmbeddingOrderByInput, List[types.EmbeddingOrderByInput]]] = None,
        distinct: Optional[List[types.EmbeddingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Embedding records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Embedding records returned
        skip
            Ignore the first N results
        where
            Embedding filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Embedding model
        order
            Order the returned Embedding records by any field
        distinct
            Filter Embedding records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Embedding]
            The list of all Embedding records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Embedding records
        embeddings = await Embedding.prisma().find_many(take=10)

        # find the first 5 Embedding records ordered by the documentId field
        embeddings = await Embedding.prisma().find_many(
            take=5,
            order={
                'documentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmbeddingWhereInput] = None,
        cursor: Optional[types.EmbeddingWhereUniqueInput] = None,
        include: Optional[types.EmbeddingInclude] = None,
        order: Optional[Union[types.EmbeddingOrderByInput, List[types.EmbeddingOrderByInput]]] = None,
        distinct: Optional[List[types.EmbeddingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Embedding record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Embedding filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Embedding model
        order
            Order the returned Embedding records by any field
        distinct
            Filter Embedding records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Embedding
            The first Embedding record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Embedding record ordered by the chunkIndex field
        embedding = await Embedding.prisma().find_first(
            skip=1,
            order={
                'chunkIndex': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmbeddingWhereInput] = None,
        cursor: Optional[types.EmbeddingWhereUniqueInput] = None,
        include: Optional[types.EmbeddingInclude] = None,
        order: Optional[Union[types.EmbeddingOrderByInput, List[types.EmbeddingOrderByInput]]] = None,
        distinct: Optional[List[types.EmbeddingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Embedding record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Embedding filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Embedding model
        order
            Order the returned Embedding records by any field
        distinct
            Filter Embedding records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Embedding
            The first Embedding record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Embedding record ordered by the content field
        embedding = await Embedding.prisma().find_first_or_raise(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmbeddingUpdateInput,
        where: types.EmbeddingWhereUniqueInput,
        include: Optional[types.EmbeddingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Embedding record.

        Parameters
        ----------
        data
            Embedding record data specifying what to update
        where
            Embedding filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Embedding model

        Returns
        -------
        prisma.models.Embedding
            The updated Embedding record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        embedding = await Embedding.prisma().update(
            where={
                'id': 'cbagggbji',
            },
            data={
                # data to update the Embedding record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmbeddingWhereUniqueInput,
        data: types.EmbeddingUpsertInput,
        include: Optional[types.EmbeddingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Embedding filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Embedding model

        Returns
        -------
        prisma.models.Embedding
            The created or updated Embedding record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        embedding = await Embedding.prisma().upsert(
            where={
                'id': 'bchgafhjed',
            },
            data={
                'create': {
                    'id': 'bchgafhjed',
                    'vectorStoreId': 'cbccbbcdfb',
                    'documentId': 'bacejedaca',
                    'chunkIndex': 1717307509,
                    'content': 'bfjibceaec',
                },
                'update': {
                    'vectorStoreId': 'cbccbbcdfb',
                    'documentId': 'bacejedaca',
                    'chunkIndex': 1717307509,
                    'content': 'bfjibceaec',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmbeddingUpdateManyMutationInput,
        where: types.EmbeddingWhereInput,
    ) -> int:
        """Update multiple Embedding records

        Parameters
        ----------
        data
            Embedding data to update the selected Embedding records to
        where
            Filter to select the Embedding records to update

        Returns
        -------
        int
            The total number of Embedding records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Embedding records
        total = await Embedding.prisma().update_many(
            data={
                'metadata': Json({'heffgjdei': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmbeddingWhereInput] = None,
        cursor: Optional[types.EmbeddingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Embedding records present in the database

        Parameters
        ----------
        select
            Select the Embedding fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Embedding filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmbeddingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Embedding.prisma().count()

        # results: prisma.types.EmbeddingCountAggregateOutput
        results = await Embedding.prisma().count(
            select={
                '_all': True,
                'vector': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmbeddingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmbeddingWhereInput] = None,
        cursor: Optional[types.EmbeddingWhereUniqueInput] = None,
    ) -> types.EmbeddingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmbeddingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmbeddingWhereInput] = None,
        cursor: Optional[types.EmbeddingWhereUniqueInput] = None,
    ) -> Union[int, types.EmbeddingCountAggregateOutput]:
        """Count the number of Embedding records present in the database

        Parameters
        ----------
        select
            Select the Embedding fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Embedding filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmbeddingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Embedding.prisma().count()

        # results: prisma.types.EmbeddingCountAggregateOutput
        results = await Embedding.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmbeddingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmbeddingWhereInput] = None
    ) -> int:
        """Delete multiple Embedding records.

        Parameters
        ----------
        where
            Optional Embedding filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Embedding records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Embedding records
        total = await Embedding.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmbeddingScalarFieldKeys'],
        *,
        where: Optional['types.EmbeddingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmbeddingAvgAggregateInput'] = None,
        sum: Optional['types.EmbeddingSumAggregateInput'] = None,
        min: Optional['types.EmbeddingMinAggregateInput'] = None,
        max: Optional['types.EmbeddingMaxAggregateInput'] = None,
        having: Optional['types.EmbeddingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmbeddingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmbeddingScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmbeddingScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmbeddingGroupByOutput']:
        """Group Embedding records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Embedding fields to group records by
        where
            Embedding filter to select records
        take
            Limit the maximum number of Embedding records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmbeddingGroupByOutput]
            A list of dictionaries representing the Embedding record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Embedding records by id values
        # and count how many records are in each group
        results = await Embedding.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MCPServerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.MCPServer]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await MCPServer.prisma().query_raw(
            'SELECT * FROM MCPServer WHERE id = $1',
            'dahihgbeb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.MCPServer
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await MCPServer.prisma().query_first(
            'SELECT * FROM MCPServer WHERE name = $1',
            'bgheaejbcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MCPServerCreateInput,
        include: Optional[types.MCPServerInclude] = None
    ) -> _PrismaModelT:
        """Create a new MCPServer record.

        Parameters
        ----------
        data
            MCPServer record data
        include
            Specifies which relations should be loaded on the returned MCPServer model

        Returns
        -------
        prisma.models.MCPServer
            The created MCPServer record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MCPServer record from just the required fields
        mcpserver = await MCPServer.prisma().create(
            data={
                # data to create a MCPServer record
                'name': 'bfcgifeged',
                'endpointUrl': 'jfiahhbae',
                'authenticationDetails': Json({'bfbdafajcb': True}),
                'securityPolicy': Json({'caeghehde': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MCPServerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MCPServer records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MCPServer record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MCPServer.prisma().create_many(
            data=[
                {
                    # data to create a MCPServer record
                    'name': 'caghgfbggd',
                    'endpointUrl': 'bbidjbbjaa',
                    'authenticationDetails': Json({'bfijhaejdd': True}),
                    'securityPolicy': Json({'bcedehfiji': True}),
                },
                {
                    # data to create a MCPServer record
                    'name': 'bdgjicijhb',
                    'endpointUrl': 'bghifjdeia',
                    'authenticationDetails': Json({'eadfcbbcb': True}),
                    'securityPolicy': Json({'geihgahba': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MCPServerWhereUniqueInput,
        include: Optional[types.MCPServerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MCPServer record.

        Parameters
        ----------
        where
            MCPServer filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MCPServer model

        Returns
        -------
        prisma.models.MCPServer
            The deleted MCPServer record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mcpserver = await MCPServer.prisma().delete(
            where={
                'id': 'gahdcdhbj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MCPServerWhereUniqueInput,
        include: Optional[types.MCPServerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MCPServer record.

        Parameters
        ----------
        where
            MCPServer filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MCPServer model

        Returns
        -------
        prisma.models.MCPServer
            The found MCPServer record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mcpserver = await MCPServer.prisma().find_unique(
            where={
                'id': 'begiijahea',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MCPServerWhereUniqueInput,
        include: Optional[types.MCPServerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MCPServer record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MCPServer filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MCPServer model

        Returns
        -------
        prisma.models.MCPServer
            The found MCPServer record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mcpserver = await MCPServer.prisma().find_unique_or_raise(
            where={
                'id': 'gcjadjaaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MCPServerWhereInput] = None,
        cursor: Optional[types.MCPServerWhereUniqueInput] = None,
        include: Optional[types.MCPServerInclude] = None,
        order: Optional[Union[types.MCPServerOrderByInput, List[types.MCPServerOrderByInput]]] = None,
        distinct: Optional[List[types.MCPServerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MCPServer records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MCPServer records returned
        skip
            Ignore the first N results
        where
            MCPServer filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MCPServer model
        order
            Order the returned MCPServer records by any field
        distinct
            Filter MCPServer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MCPServer]
            The list of all MCPServer records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MCPServer records
        mcpservers = await MCPServer.prisma().find_many(take=10)

        # find the first 5 MCPServer records ordered by the endpointUrl field
        mcpservers = await MCPServer.prisma().find_many(
            take=5,
            order={
                'endpointUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MCPServerWhereInput] = None,
        cursor: Optional[types.MCPServerWhereUniqueInput] = None,
        include: Optional[types.MCPServerInclude] = None,
        order: Optional[Union[types.MCPServerOrderByInput, List[types.MCPServerOrderByInput]]] = None,
        distinct: Optional[List[types.MCPServerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MCPServer record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MCPServer filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MCPServer model
        order
            Order the returned MCPServer records by any field
        distinct
            Filter MCPServer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MCPServer
            The first MCPServer record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MCPServer record ordered by the authenticationDetails field
        mcpserver = await MCPServer.prisma().find_first(
            skip=1,
            order={
                'authenticationDetails': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MCPServerWhereInput] = None,
        cursor: Optional[types.MCPServerWhereUniqueInput] = None,
        include: Optional[types.MCPServerInclude] = None,
        order: Optional[Union[types.MCPServerOrderByInput, List[types.MCPServerOrderByInput]]] = None,
        distinct: Optional[List[types.MCPServerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MCPServer record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MCPServer filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MCPServer model
        order
            Order the returned MCPServer records by any field
        distinct
            Filter MCPServer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MCPServer
            The first MCPServer record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MCPServer record ordered by the capabilities field
        mcpserver = await MCPServer.prisma().find_first_or_raise(
            skip=1,
            order={
                'capabilities': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MCPServerUpdateInput,
        where: types.MCPServerWhereUniqueInput,
        include: Optional[types.MCPServerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MCPServer record.

        Parameters
        ----------
        data
            MCPServer record data specifying what to update
        where
            MCPServer filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MCPServer model

        Returns
        -------
        prisma.models.MCPServer
            The updated MCPServer record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        mcpserver = await MCPServer.prisma().update(
            where={
                'id': 'bcbebgiaic',
            },
            data={
                # data to update the MCPServer record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MCPServerWhereUniqueInput,
        data: types.MCPServerUpsertInput,
        include: Optional[types.MCPServerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MCPServer filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MCPServer model

        Returns
        -------
        prisma.models.MCPServer
            The created or updated MCPServer record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mcpserver = await MCPServer.prisma().upsert(
            where={
                'id': 'ijigbdcbj',
            },
            data={
                'create': {
                    'id': 'ijigbdcbj',
                    'name': 'bdgjicijhb',
                    'endpointUrl': 'bghifjdeia',
                    'authenticationDetails': Json({'eadfcbbcb': True}),
                    'securityPolicy': Json({'geihgahba': True}),
                },
                'update': {
                    'name': 'bdgjicijhb',
                    'endpointUrl': 'bghifjdeia',
                    'authenticationDetails': Json({'eadfcbbcb': True}),
                    'securityPolicy': Json({'geihgahba': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MCPServerUpdateManyMutationInput,
        where: types.MCPServerWhereInput,
    ) -> int:
        """Update multiple MCPServer records

        Parameters
        ----------
        data
            MCPServer data to update the selected MCPServer records to
        where
            Filter to select the MCPServer records to update

        Returns
        -------
        int
            The total number of MCPServer records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MCPServer records
        total = await MCPServer.prisma().update_many(
            data={
                'securityPolicy': Json({'gfidhicai': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MCPServerWhereInput] = None,
        cursor: Optional[types.MCPServerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MCPServer records present in the database

        Parameters
        ----------
        select
            Select the MCPServer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MCPServer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MCPServerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MCPServer.prisma().count()

        # results: prisma.types.MCPServerCountAggregateOutput
        results = await MCPServer.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MCPServerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MCPServerWhereInput] = None,
        cursor: Optional[types.MCPServerWhereUniqueInput] = None,
    ) -> types.MCPServerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MCPServerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MCPServerWhereInput] = None,
        cursor: Optional[types.MCPServerWhereUniqueInput] = None,
    ) -> Union[int, types.MCPServerCountAggregateOutput]:
        """Count the number of MCPServer records present in the database

        Parameters
        ----------
        select
            Select the MCPServer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MCPServer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MCPServerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MCPServer.prisma().count()

        # results: prisma.types.MCPServerCountAggregateOutput
        results = await MCPServer.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MCPServerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MCPServerWhereInput] = None
    ) -> int:
        """Delete multiple MCPServer records.

        Parameters
        ----------
        where
            Optional MCPServer filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MCPServer records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MCPServer records
        total = await MCPServer.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MCPServerScalarFieldKeys'],
        *,
        where: Optional['types.MCPServerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MCPServerAvgAggregateInput'] = None,
        sum: Optional['types.MCPServerSumAggregateInput'] = None,
        min: Optional['types.MCPServerMinAggregateInput'] = None,
        max: Optional['types.MCPServerMaxAggregateInput'] = None,
        having: Optional['types.MCPServerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MCPServerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MCPServerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MCPServerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MCPServerGroupByOutput']:
        """Group MCPServer records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MCPServer fields to group records by
        where
            MCPServer filter to select records
        take
            Limit the maximum number of MCPServer records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MCPServerGroupByOutput]
            A list of dictionaries representing the MCPServer record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MCPServer records by updatedAt values
        # and count how many records are in each group
        results = await MCPServer.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EvaluationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Evaluation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Evaluation.prisma().query_raw(
            'SELECT * FROM Evaluation WHERE id = $1',
            'jfegcaafh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Evaluation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Evaluation.prisma().query_first(
            'SELECT * FROM Evaluation WHERE agentId = $1',
            'bcbeiajjfa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EvaluationCreateInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Evaluation record.

        Parameters
        ----------
        data
            Evaluation record data
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The created Evaluation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Evaluation record from just the required fields
        evaluation = await Evaluation.prisma().create(
            data={
                # data to create a Evaluation record
                'agentId': 'baehicaajf',
                'name': 'bdachdeiga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EvaluationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Evaluation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Evaluation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Evaluation.prisma().create_many(
            data=[
                {
                    # data to create a Evaluation record
                    'agentId': 'ijdafccef',
                    'name': 'ciaaiddag',
                },
                {
                    # data to create a Evaluation record
                    'agentId': 'fejggijff',
                    'name': 'hghjaaai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Evaluation record.

        Parameters
        ----------
        where
            Evaluation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The deleted Evaluation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().delete(
            where={
                'id': 'cajicjjdef',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Evaluation record.

        Parameters
        ----------
        where
            Evaluation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The found Evaluation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().find_unique(
            where={
                'id': 'cefjaadec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Evaluation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Evaluation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The found Evaluation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().find_unique_or_raise(
            where={
                'id': 'ibbigdigd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
        include: Optional[types.EvaluationInclude] = None,
        order: Optional[Union[types.EvaluationOrderByInput, List[types.EvaluationOrderByInput]]] = None,
        distinct: Optional[List[types.EvaluationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Evaluation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Evaluation records returned
        skip
            Ignore the first N results
        where
            Evaluation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Evaluation model
        order
            Order the returned Evaluation records by any field
        distinct
            Filter Evaluation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Evaluation]
            The list of all Evaluation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Evaluation records
        evaluations = await Evaluation.prisma().find_many(take=10)

        # find the first 5 Evaluation records ordered by the name field
        evaluations = await Evaluation.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
        include: Optional[types.EvaluationInclude] = None,
        order: Optional[Union[types.EvaluationOrderByInput, List[types.EvaluationOrderByInput]]] = None,
        distinct: Optional[List[types.EvaluationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Evaluation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Evaluation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Evaluation model
        order
            Order the returned Evaluation records by any field
        distinct
            Filter Evaluation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Evaluation
            The first Evaluation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Evaluation record ordered by the description field
        evaluation = await Evaluation.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
        include: Optional[types.EvaluationInclude] = None,
        order: Optional[Union[types.EvaluationOrderByInput, List[types.EvaluationOrderByInput]]] = None,
        distinct: Optional[List[types.EvaluationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Evaluation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Evaluation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Evaluation model
        order
            Order the returned Evaluation records by any field
        distinct
            Filter Evaluation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Evaluation
            The first Evaluation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Evaluation record ordered by the testDatasetId field
        evaluation = await Evaluation.prisma().find_first_or_raise(
            skip=1,
            order={
                'testDatasetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EvaluationUpdateInput,
        where: types.EvaluationWhereUniqueInput,
        include: Optional[types.EvaluationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Evaluation record.

        Parameters
        ----------
        data
            Evaluation record data specifying what to update
        where
            Evaluation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The updated Evaluation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().update(
            where={
                'id': 'bdiiiabbii',
            },
            data={
                # data to update the Evaluation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EvaluationWhereUniqueInput,
        data: types.EvaluationUpsertInput,
        include: Optional[types.EvaluationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Evaluation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Evaluation model

        Returns
        -------
        prisma.models.Evaluation
            The created or updated Evaluation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        evaluation = await Evaluation.prisma().upsert(
            where={
                'id': 'hfcfhhadh',
            },
            data={
                'create': {
                    'id': 'hfcfhhadh',
                    'agentId': 'fejggijff',
                    'name': 'hghjaaai',
                },
                'update': {
                    'agentId': 'fejggijff',
                    'name': 'hghjaaai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EvaluationUpdateManyMutationInput,
        where: types.EvaluationWhereInput,
    ) -> int:
        """Update multiple Evaluation records

        Parameters
        ----------
        data
            Evaluation data to update the selected Evaluation records to
        where
            Filter to select the Evaluation records to update

        Returns
        -------
        int
            The total number of Evaluation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Evaluation records
        total = await Evaluation.prisma().update_many(
            data={
                'metrics': Json({'bbihggdcji': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Evaluation records present in the database

        Parameters
        ----------
        select
            Select the Evaluation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Evaluation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EvaluationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Evaluation.prisma().count()

        # results: prisma.types.EvaluationCountAggregateOutput
        results = await Evaluation.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EvaluationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
    ) -> types.EvaluationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EvaluationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EvaluationWhereInput] = None,
        cursor: Optional[types.EvaluationWhereUniqueInput] = None,
    ) -> Union[int, types.EvaluationCountAggregateOutput]:
        """Count the number of Evaluation records present in the database

        Parameters
        ----------
        select
            Select the Evaluation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Evaluation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EvaluationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Evaluation.prisma().count()

        # results: prisma.types.EvaluationCountAggregateOutput
        results = await Evaluation.prisma().count(
            select={
                '_all': True,
                'results': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EvaluationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EvaluationWhereInput] = None
    ) -> int:
        """Delete multiple Evaluation records.

        Parameters
        ----------
        where
            Optional Evaluation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Evaluation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Evaluation records
        total = await Evaluation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EvaluationScalarFieldKeys'],
        *,
        where: Optional['types.EvaluationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EvaluationAvgAggregateInput'] = None,
        sum: Optional['types.EvaluationSumAggregateInput'] = None,
        min: Optional['types.EvaluationMinAggregateInput'] = None,
        max: Optional['types.EvaluationMaxAggregateInput'] = None,
        having: Optional['types.EvaluationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EvaluationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EvaluationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EvaluationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EvaluationGroupByOutput']:
        """Group Evaluation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Evaluation fields to group records by
        where
            Evaluation filter to select records
        take
            Limit the maximum number of Evaluation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EvaluationGroupByOutput]
            A list of dictionaries representing the Evaluation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Evaluation records by startTime values
        # and count how many records are in each group
        results = await Evaluation.prisma().group_by(
            ['startTime'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'hgjgibdgd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'bcbecjfice',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'bacbebhjjd',
                'username': 'dfbfaddhe',
                'hashedPassword': 'bdcbbieibf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'dgjhdcggi',
                    'username': 'bbjbcdfabd',
                    'hashedPassword': 'gchfgbcec',
                },
                {
                    # data to create a User record
                    'email': 'bihcjfcjah',
                    'username': 'bhjdcicaii',
                    'hashedPassword': 'bibedjhcej',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'bjcdajabfa',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bchhceeeff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'bbgaifhdaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the hashedPassword field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'hashedPassword': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the isActive field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'dgbcdaegb',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'beagfbbjig',
            },
            data={
                'create': {
                    'id': 'beagfbbjig',
                    'email': 'bihcjfcjah',
                    'username': 'bhjdcicaii',
                    'hashedPassword': 'bibedjhcej',
                },
                'update': {
                    'email': 'bihcjfcjah',
                    'username': 'bhjdcicaii',
                    'hashedPassword': 'bibedjhcej',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'isAdmin': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by updatedAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SystemConfigActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SystemConfig]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SystemConfig.prisma().query_raw(
            'SELECT * FROM SystemConfig WHERE id = $1',
            'fgggcdcjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SystemConfig
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SystemConfig.prisma().query_first(
            'SELECT * FROM SystemConfig WHERE key = $1',
            'ccjbbjigf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SystemConfigCreateInput,
        include: Optional[types.SystemConfigInclude] = None
    ) -> _PrismaModelT:
        """Create a new SystemConfig record.

        Parameters
        ----------
        data
            SystemConfig record data
        include
            Specifies which relations should be loaded on the returned SystemConfig model

        Returns
        -------
        prisma.models.SystemConfig
            The created SystemConfig record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SystemConfig record from just the required fields
        systemconfig = await SystemConfig.prisma().create(
            data={
                # data to create a SystemConfig record
                'key': 'bhfaabbaha',
                'value': Json({'ebajedhhf': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SystemConfigCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SystemConfig records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SystemConfig record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SystemConfig.prisma().create_many(
            data=[
                {
                    # data to create a SystemConfig record
                    'key': 'jajacedge',
                    'value': Json({'hffgbabgf': True}),
                },
                {
                    # data to create a SystemConfig record
                    'key': 'biacbiieja',
                    'value': Json({'cjejbgbff': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SystemConfigWhereUniqueInput,
        include: Optional[types.SystemConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SystemConfig record.

        Parameters
        ----------
        where
            SystemConfig filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SystemConfig model

        Returns
        -------
        prisma.models.SystemConfig
            The deleted SystemConfig record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemconfig = await SystemConfig.prisma().delete(
            where={
                'id': 'fgeahddae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SystemConfigWhereUniqueInput,
        include: Optional[types.SystemConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SystemConfig record.

        Parameters
        ----------
        where
            SystemConfig filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemConfig model

        Returns
        -------
        prisma.models.SystemConfig
            The found SystemConfig record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemconfig = await SystemConfig.prisma().find_unique(
            where={
                'id': 'diageigcf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SystemConfigWhereUniqueInput,
        include: Optional[types.SystemConfigInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SystemConfig record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SystemConfig filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemConfig model

        Returns
        -------
        prisma.models.SystemConfig
            The found SystemConfig record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemconfig = await SystemConfig.prisma().find_unique_or_raise(
            where={
                'id': 'badagbgeha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemConfigWhereInput] = None,
        cursor: Optional[types.SystemConfigWhereUniqueInput] = None,
        include: Optional[types.SystemConfigInclude] = None,
        order: Optional[Union[types.SystemConfigOrderByInput, List[types.SystemConfigOrderByInput]]] = None,
        distinct: Optional[List[types.SystemConfigScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SystemConfig records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SystemConfig records returned
        skip
            Ignore the first N results
        where
            SystemConfig filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemConfig model
        order
            Order the returned SystemConfig records by any field
        distinct
            Filter SystemConfig records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SystemConfig]
            The list of all SystemConfig records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SystemConfig records
        systemconfigs = await SystemConfig.prisma().find_many(take=10)

        # find the first 5 SystemConfig records ordered by the value field
        systemconfigs = await SystemConfig.prisma().find_many(
            take=5,
            order={
                'value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemConfigWhereInput] = None,
        cursor: Optional[types.SystemConfigWhereUniqueInput] = None,
        include: Optional[types.SystemConfigInclude] = None,
        order: Optional[Union[types.SystemConfigOrderByInput, List[types.SystemConfigOrderByInput]]] = None,
        distinct: Optional[List[types.SystemConfigScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SystemConfig record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemConfig filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemConfig model
        order
            Order the returned SystemConfig records by any field
        distinct
            Filter SystemConfig records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemConfig
            The first SystemConfig record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemConfig record ordered by the createdAt field
        systemconfig = await SystemConfig.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemConfigWhereInput] = None,
        cursor: Optional[types.SystemConfigWhereUniqueInput] = None,
        include: Optional[types.SystemConfigInclude] = None,
        order: Optional[Union[types.SystemConfigOrderByInput, List[types.SystemConfigOrderByInput]]] = None,
        distinct: Optional[List[types.SystemConfigScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SystemConfig record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemConfig filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemConfig model
        order
            Order the returned SystemConfig records by any field
        distinct
            Filter SystemConfig records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemConfig
            The first SystemConfig record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemConfig record ordered by the updatedAt field
        systemconfig = await SystemConfig.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SystemConfigUpdateInput,
        where: types.SystemConfigWhereUniqueInput,
        include: Optional[types.SystemConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SystemConfig record.

        Parameters
        ----------
        data
            SystemConfig record data specifying what to update
        where
            SystemConfig filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SystemConfig model

        Returns
        -------
        prisma.models.SystemConfig
            The updated SystemConfig record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        systemconfig = await SystemConfig.prisma().update(
            where={
                'id': 'ibgebbjch',
            },
            data={
                # data to update the SystemConfig record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SystemConfigWhereUniqueInput,
        data: types.SystemConfigUpsertInput,
        include: Optional[types.SystemConfigInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SystemConfig filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SystemConfig model

        Returns
        -------
        prisma.models.SystemConfig
            The created or updated SystemConfig record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemconfig = await SystemConfig.prisma().upsert(
            where={
                'id': 'baieajjiee',
            },
            data={
                'create': {
                    'id': 'baieajjiee',
                    'key': 'biacbiieja',
                    'value': Json({'cjejbgbff': True}),
                },
                'update': {
                    'key': 'biacbiieja',
                    'value': Json({'cjejbgbff': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SystemConfigUpdateManyMutationInput,
        where: types.SystemConfigWhereInput,
    ) -> int:
        """Update multiple SystemConfig records

        Parameters
        ----------
        data
            SystemConfig data to update the selected SystemConfig records to
        where
            Filter to select the SystemConfig records to update

        Returns
        -------
        int
            The total number of SystemConfig records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SystemConfig records
        total = await SystemConfig.prisma().update_many(
            data={
                'id': 'bahjhaccfd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemConfigWhereInput] = None,
        cursor: Optional[types.SystemConfigWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SystemConfig records present in the database

        Parameters
        ----------
        select
            Select the SystemConfig fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemConfig filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemConfig.prisma().count()

        # results: prisma.types.SystemConfigCountAggregateOutput
        results = await SystemConfig.prisma().count(
            select={
                '_all': True,
                'key': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SystemConfigCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemConfigWhereInput] = None,
        cursor: Optional[types.SystemConfigWhereUniqueInput] = None,
    ) -> types.SystemConfigCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SystemConfigCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemConfigWhereInput] = None,
        cursor: Optional[types.SystemConfigWhereUniqueInput] = None,
    ) -> Union[int, types.SystemConfigCountAggregateOutput]:
        """Count the number of SystemConfig records present in the database

        Parameters
        ----------
        select
            Select the SystemConfig fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemConfig filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemConfig.prisma().count()

        # results: prisma.types.SystemConfigCountAggregateOutput
        results = await SystemConfig.prisma().count(
            select={
                '_all': True,
                'value': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SystemConfigCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SystemConfigWhereInput] = None
    ) -> int:
        """Delete multiple SystemConfig records.

        Parameters
        ----------
        where
            Optional SystemConfig filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SystemConfig records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SystemConfig records
        total = await SystemConfig.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SystemConfigScalarFieldKeys'],
        *,
        where: Optional['types.SystemConfigWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SystemConfigAvgAggregateInput'] = None,
        sum: Optional['types.SystemConfigSumAggregateInput'] = None,
        min: Optional['types.SystemConfigMinAggregateInput'] = None,
        max: Optional['types.SystemConfigMaxAggregateInput'] = None,
        having: Optional['types.SystemConfigScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SystemConfigCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SystemConfigScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SystemConfigScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SystemConfigGroupByOutput']:
        """Group SystemConfig records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SystemConfig fields to group records by
        where
            SystemConfig filter to select records
        take
            Limit the maximum number of SystemConfig records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SystemConfigGroupByOutput]
            A list of dictionaries representing the SystemConfig record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SystemConfig records by createdAt values
        # and count how many records are in each group
        results = await SystemConfig.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models